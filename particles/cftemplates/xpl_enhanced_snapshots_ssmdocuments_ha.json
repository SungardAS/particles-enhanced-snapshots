{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "This template was built to run in us-east-1 and will create resources to run enhanced-snapshots (https://github.com/sungardas/enhanced-snapshots) in high availability mode . Templates for other regions can be found at https://github.com/sungardas/particle-enhanced-snapshots",
  "Resources": {
    "ESSLinuxFreeze": {
      "Type": "AWS::SSM::Document",
      "Properties": {
        "Content": {
          "schemaVersion": "1.2",
          "description": "ESS",
          "parameters": {
            "device": {
              "type": "String",
              "description": "Device to be freezed",
              "allowedPattern": "/dev/[a-z]{3,4}"
            },
            "instanceId": {
              "type": "String",
              "description": "InstanceId for healthcheck",
              "allowedPattern": "i-[a-z0-9]{17}"
            },
            "region": {
              "type": "String",
              "description": "Region for instanceId"
            },
            "documentName": {
              "type": "String",
              "description": "Name of the document for healthcheck"
            },
            "appURL": {
              "type": "String",
              "description": "URL for healthcheck",
              "allowedPattern": "https://.*"
            },
            "timeout": {
              "type": "String",
              "default": "300",
              "description": "(Optional) Operation timeout",
              "allowedPattern": "[1-9][0-9]{2,3}"
            }
          },
          "runtimeConfig": {
            "aws:runShellScript": {
              "properties": [
                {
                  "id": "0.aws:runShellScript",
                  "runCommand": [
                    "#!/bin/sh",
                    "DEVICE=\"{{ device }}\"",
                    "INSTANCEID=\"{{ instanceId }}\"",
                    "REGION=\"{{ region }}\"",
                    "DOCUMENTNAME=\"{{ documentName }}\"",
                    "TIMEOUT=\"{{ timeout }}\"",
                    "APPURL=\"{{ appURL }}\"",
                    "[ -z \"$(lsblk -o NAME -rnp | grep \"${DEVICE}\")\" ] && DEVICE=$(find /dev -regex \"^${DEVICE}$\" -type l -exec realpath {} \\;)",
                    "[ -z \"${DEVICE}\" ] && echo \" EXIT_RESULT: No_Device_Found\" && exit 0 || echo \"DEVICE: ${DEVICE}\"",
                    "SUPPORTED=$(lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* (ext3|ext4|reiserfs|xfs) /.+\" | wc -l)",
                    "ALL=$(lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* .+ /.+\" | wc -l)",
                    "[ \"${SUPPORTED}\" -ne \"${ALL}\" ] && echo \"EXIT_RESULT: Unsupported_FS\" && exit 0",
                    "[ -z \"$(which fsfreeze)\" ] && echo \"EXIT_RESULT: No_FsFreeze_Tool\" && exit 0",
                    "lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* (ext3|ext4|reiserfs|xfs) /.+\"|",
                    "while read DEV NAME MOUNTPOINT; do",
                    "echo \"freezing ${DEV}: ${MOUNTPOINT}\" ; $(which fsfreeze) -f ${MOUNTPOINT}",
                    "if [ $? != 0 ]; then echo \"EXIT_RESULT: Fsfreeze_failed_${MOUNTPOINT}\"; else",
                    "MPS=\"$MPS $MOUNTPOINT\" ; echo ${MPS} > /tmp/var",
                    "fi",
                    "done",
                    "(",
                    "sleep $TIMEOUT",
                    "[ ! -f /tmp/var ] && exit 0",
                    "if [ -z \"$(which aws)\" ]; then",
                    "check=$(curl -k -s -o /dev/null -w \"%{http_code}\" ${APPURL})",
                    "sleep 5",
                    "check=$(curl -k -s -o /dev/null -w \"%{http_code}\" ${APPURL})",
                    "if [ \"${check}\" != \"200\" ] && [ \"${check2}\" != \"200\" ]; then",
                    "sleep 5",
                    "check3=$(curl -k -s -o /dev/null -w \"%{http_code}\" ${APPURL})",
                    "if [ \"${check3}\" -ne \"200\" ]; then",
                    "for MP in $(cat /tmp/var); do $(which fsfreeze) -u ${MP}; done",
                    "exit 0",
                    "fi",
                    "fi",
                    "else",
                    "COMMANDID=$(aws ssm send-command --document-name \"${DOCUMENTNAME}\" --instance-ids \"${INSTANCEID}\" --region \"${REGION}\" --output text | head -n1 | awk {'print $2'})",
                    "sleep 15",
                    "RES=\"\"",
                    "if [ ! -z \"${COMMANDID}\" ]; then",
                    "if ! aws ssm list-command-invocations --command-id \"${COMMANDID}\" --details --output text | grep \"EXIT_RESULT: Success\"; then",
                    "for MP in $(cat /tmp/var); do $(which fsfreeze) -u ${MP}; done",
                    "fi",
                    "else",
                    "for MP in $(cat /tmp/var); do $(which fsfreeze) -u ${MP}; done",
                    "fi",
                    "fi",
                    ") &",
                    "echo \"EXIT_RESULT: Frozen\"",
                    "exit 0"
                  ]
                }
              ]
            }
          }
        }
      }
    },
    "ESSLinuxUnFreeze": {
      "Type": "AWS::SSM::Document",
      "Properties": {
        "Content": {
          "schemaVersion": "1.2",
          "description": "ESS",
          "parameters": {
            "device": {
              "type": "String",
              "description": "Device to be unfreezed",
              "allowedPattern": "/dev/[a-z]{3,4}"
            }
          },
          "runtimeConfig": {
            "aws:runShellScript": {
              "properties": [
                {
                  "id": "0.aws:runShellScript",
                  "runCommand": [
                    "#!/bin/sh",
                    "DEVICE=\"{{ device }}\"",
                    "[ -z \"$(lsblk -o NAME -rnp | grep \"${DEVICE}\")\" ] && DEVICE=$(find /dev -regex \"^${DEVICE}$\" -type l -exec realpath {} \\;)",
                    "[ -z \"${DEVICE}\" ] && echo \" EXIT_RESULT: No_Device_Found\" && exit 0 || echo \"DEVICE: ${DEVICE}\"",
                    "SUPPORTED=$(lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* (ext3|ext4|reiserfs|xfs) /.+\" | wc -l)",
                    "ALL=$(lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* .+ /.+\" | wc -l)",
                    "[ \"${SUPPORTED}\" -ne \"${ALL}\" ] && echo \"EXIT_RESULT: Unsupported_FS\" && exit 0",
                    "[ -z \"$(which fsfreeze)\" ] && echo \"EXIT_RESULT: No_FsFreeze_Tool\" && exit 0",
                    "lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* (ext3|ext4|reiserfs|xfs) /.+\"|",
                    "while read DEV NAME MOUNTPOINT; do",
                    "echo \"unfreezing ${DEV}: ${MOUNTPOINT}\" ; $(which fsfreeze) -u ${MOUNTPOINT}",
                    "if [ $? != 0 ]; then echo \"EXIT_RESULT: Failed_Unfreeze_${MOUNTPOINT}\"; exit 0; fi",
                    "done",
                    "rm -f /tmp/var",
                    "echo \"EXIT_RESULT: Unfrozen\"",
                    "exit 0"
                  ]
                }
              ]
            }
          }
        }
      }
    },
    "ESSWindowsCreateVSS": {
      "Type": "AWS::SSM::Document",
      "Properties": {
        "Content": {
          "schemaVersion": "1.2",
          "description": "ESS",
          "parameters": {
            "device": {
              "type": "String",
              "description": "Device for VSS",
              "allowedPattern": "[a-z]{3,4}"
            },
            "timeout": {
              "type": "String",
              "default": "120",
              "description": "(Optional) Operation timeout",
              "allowedPattern": "[1-9][0-9]{1,3}"
            }
          },
          "runtimeConfig": {
            "aws:runPowerShellScript": {
              "properties": [
                {
                  "id": "0.aws:runPowerShellScript",
                  "runCommand": [
                    "$Mydevice = \"{{ device }}\"",
                    "$Ids = \"\"",
                    "Write-Host \"My device: $Mydevice\"",
                    "$Map = @{\"0\" = '/dev/sda1'}",
                    "for($x = 1; $x -le 25; $x++) {$Map.add($x.ToString(), [String]::Format(\"xvd{0}\",[char](97 + $x)))}",
                    "for($x = 26; $x -le 51; $x++) {$Map.add($x.ToString(), [String]::Format(\"xvda{0}\",[char](71 + $x)))}",
                    "for($x = 52; $x -le 77; $x++) {$Map.add($x.ToString(), [String]::Format(\"xvdb{0}\",[char](45 + $x)))}",
                    "for($x = 78; $x -le 103; $x++) {$Map.add($x.ToString(), [String]::Format(\"xvdc{0}\",[char](19 + $x)))}",
                    "for($x = 104; $x -le 129; $x++) {$Map.add($x.ToString(), [String]::Format(\"xvdd{0}\",[char]($x - 7)))}",
                    "Get-WmiObject -Class Win32_DiskDrive | Where-Object {$Map[$_.SCSITargetId.ToString()] -eq $Mydevice} | % {",
                    "$Drive = $_",
                    "Get-WmiObject -Class Win32_DiskDriveToDiskPartition |  Where-Object {$_.Antecedent -eq $Drive.Path.Path} | %{",
                    "$D2P = $_",
                    "$Disk = Get-WmiObject -Class Win32_LogicalDiskToPartition | Where-Object {$_.Antecedent -in $D2P.Dependent} | %{",
                    "$L2P = $_",
                    "Get-WmiObject -Class Win32_LogicalDisk | Where-Object {$_.Path.Path -in $L2P.Dependent}",
                    "}",
                    "If($Disk -ne $NULL) {",
                    "New-Object PSObject -Property @{",
                    "Device = $Map[$Drive.SCSITargetId.ToString()];",
                    "DriveLetter = $Disk.DeviceID;",
                    "}",
                    "}",
                    "}",
                    "} | Sort-Object DriveLetter | % {",
                    "$DriveLetter = $_ | Select -ExpandProperty \"DriveLetter\"",
                    "Write-Host \"Performing Shadow Copy on $DriveLetter\"",
                    "$result = vssadmin create shadow /for=$DriveLetter | Select-String 'Shadow Copy ID'",
                    "if ($result -ne $NULL) {",
                    "$result = $result -replace \"Shadow Copy ID:\",\"\"",
                    "$Ids = \"$Ids $result\"",
                    "}",
                    "}",
                    "Write-Host \"SNAPSHOT_ID: $Ids\"",
                    "Write-Host \"EXIT_RESULT: Frozen\""
                  ],
                  "timeoutSeconds": "{{ timeout }}"
                }
              ]
            }
          }
        }
      }
    },
    "ESSWindowsDeleteVSS": {
      "Type": "AWS::SSM::Document",
      "Properties": {
        "Content": {
          "schemaVersion": "1.2",
          "description": "ESS",
          "parameters": {
            "vssIds": {
              "type": "String",
              "description": "Shadow copies to remove",
              "allowedPattern": ".*"
            },
            "timeout": {
              "type": "String",
              "default": "60",
              "description": "(Optional) Operation timeout",
              "allowedPattern": "[1-9][0-9]{1,3}"
            }
          },
          "runtimeConfig": {
            "aws:runPowerShellScript": {
              "properties": [
                {
                  "id": "0.aws:runPowerShellScript",
                  "runCommand": [
                    "$Ids=\"{{ vssIds }}\"",
                    "$Array = [string[]]$Ids.Split()",
                    "Get-WmiObject Win32_Shadowcopy | % {",
                    "Write-Host \"Checking \"$_.ID",
                    "if ($Array -contains $_.ID) {",
                    "Write-Host \"Found \"$_.ID",
                    "try {",
                    "$_.Delete()",
                    "}",
                    "Catch {",
                    "Write-Host \"Error occured while removing\"",
                    "}",
                    "Finally{",
                    "Write-Host \"Item removed\"",
                    "}",
                    "}",
                    "}",
                    "Write-Host \"EXIT_RESULT: Success\""
                  ],
                  "timeoutSeconds": "{{ timeout }}"
                }
              ]
            }
          }
        }
      }
    },
    "ESSLinuxFreezeSupport": {
      "Type": "AWS::SSM::Document",
      "Properties": {
        "Content": {
          "schemaVersion": "1.2",
          "description": "ESS",
          "parameters": {
            "device": {
              "type": "String",
              "description": "Device to be freezed",
              "allowedPattern": "/dev/[a-z]{3,4}"
            }
          },
          "runtimeConfig": {
            "aws:runShellScript": {
              "properties": [
                {
                  "id": "0.aws:runShellScript",
                  "runCommand": [
                    "#!/bin/sh",
                    "DEVICE=\"{{ device }}\"",
                    "[ -z \"$(lsblk -o NAME -rnp | grep \"${DEVICE}\")\" ] && DEVICE=$(find /dev -regex \"^${DEVICE}$\" -type l -exec realpath {} \\;)",
                    "[ -z \"${DEVICE}\" ] && echo \"No devices found\\nFREEZE_SUPPORT: false\" && exit 0 || echo \"DEVICE: ${DEVICE}\"",
                    "SUPPORTED=$(lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* (ext3|ext4|reiserfs|xfs) /.+\" | wc -l)",
                    "ALL=$(lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* .+ /.+\" | wc -l)",
                    "[ \"${SUPPORTED}\" -ne \"${ALL}\" ] && echo \"Filesystems not supported\\nFREEZE_SUPPORT: false\" && exit 0",
                    "[ -z \"$(which fsfreeze)\" ] && echo \"Tool not available\\nFREEZE_SUPPORT: false\" && exit 0",
                    "echo  \"DEVICES to freeze: \"",
                    "lsblk -o NAME,FSTYPE,MOUNTPOINT -rnp | grep -E \"${DEVICE}[0-9]* (ext3|ext4|reiserfs|xfs) /.+\"",
                    "echo \"FREEZE_SUPPORT: true\"",
                    "exit 0"
                  ]
                }
              ]
            }
          }
        }
      }
    },
    "ESSCheckApp": {
      "Type": "AWS::SSM::Document",
      "Properties": {
        "Content": {
          "schemaVersion": "1.2",
          "description": "ESS",
          "parameters": {
            "appURL": {
              "type": "String",
              "description": "App URL",
              "default": "https://localhost"
            }
          },
          "runtimeConfig": {
            "aws:runShellScript": {
              "properties": [
                {
                  "id": "0.aws:runShellScript",
                  "runCommand": [
                    "#!/bin/sh",
                    "APPURL=\"{{ appURL }}\"",
                    "check=$(curl -k -s -o /dev/null -w \"%{http_code}\" ${APPURL})",
                    "sleep 3",
                    "check=$(curl -k -s -o /dev/null -w \"%{http_code}\" ${APPURL})",
                    "if [ \"${check}\" != \"200\" ] && [ \"${check2}\" != \"200\" ]; then",
                    "echo \"EXIT_RESULT: Error\"",
                    "else",
                    "echo \"EXIT_RESULT: Success\"",
                    "fi",
                    "exit 0"
                  ],
                  "timeoutSeconds": "10"
                }
              ]
            }
          }
        }
      }
    }
  }
}